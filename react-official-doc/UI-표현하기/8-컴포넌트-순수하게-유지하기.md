# 🔗 [컴포넌트 순수하게 유지하기](https://ko.react.dev/learn/keeping-components-pure)

## 엄격 모드로 순수하지 않은 연산을 감지

사용자의 입력에 따라 무언가를 변경 하려는 경우, 변수를 직접 수정하는 대신 set state를 활용해야 합니다. 컴포넌트가 렌더링되는 동안엔 기존 변수나 개체를 변경하면 안됩니다.

React는 개발 중에 각 컴포넌트의 함수를 두 번 호출하는 “엄격 모드”를 제공합니다. 컴포넌트 함수를 두 번 호출함으로써, 엄격 모드는 이러한 규칙을 위반하는 컴포넌트를 찾는데 도움을 줍니다.

순수 함수는 연산만 하므로 두 번 호출해도 아무 것도 변경되지 않습니다.`—double(2)`을 두번 호출하는게 반환된 것을 변경하지 않고 y = 2x을 두 번 푸는게 y의 답을 바꾸지 않는 것 처럼, 항상 같은 입력이면 같은 출력입니다.

엄격 모드는 프로덕션에 영향을 주지 않기 때문에 사용자의 앱 속도가 느려지지 않습니다. 엄격 모드를 사용하기 위해서, 최상단 컴포넌트를 `<React.StrictMode>`로 감쌀 수 있습니다. 몇몇 프레임워크는 기본적으로 이 문법을 사용합니다.

## 부작용을 일으킬 수 있는 지점

함수형 프로그래밍은 순수성에 크게 의존하지만, 언젠가는, 어딘가에서, 무언가가 바뀌어야 합니다. 그것이 프로그래밍의 요점입니다! 이러한 변화들-화면을 업데이트하고, 애니메이션을 시작하고, 데이터를 변경하는 것을 사이드 이펙트라고 합니다. 렌더링중에 발생하는 것이 아니라 “사이드에서,” 발생하는 현상입니다.

리액트에선, 사이드 이펙트는 보통 이벤트 핸들러에 포함됩니다. 이벤트 핸들러는 리액트가 일부 작업을 수행할 때 반응하는 기능입니다-예를 들면 버튼을 클릭할 때처럼 말이죠. 이벤트 핸들러가 컴포넌트 내부에 정의되었다 하더라도 렌더링 중에는 실행되지 않습니다! 그래서 이벤트 핸들러는 순수할 필요가 없습니다.

다른 옵션을 모두 사용했지만 사이드 이펙트에 적합한 이벤트 핸들러를 찾을 수 없는 경우에도, 컴포넌트에서 `useEffect` 호출을 사용하여 반환된 JSX에 해당 이벤트 핸들러를 연결할 수 있습니다. 이것은 리액트에게 사이드 이펙트가 허용될 때 렌더링 후 나중에 실행하도록 지시합니다. 그러나 이 접근 방식이 마지막 수단이 되어야 합니다.

## 리액트는 왜 순수함을 신경쓸까요?

순수 함수를 작성하려면 약간의 습관과 훈련이 필요합니다. 그러나 이건 또한 놀라운 기회를 열어줍니다.

- 컴포넌트는 다른 환경에서도 실행될 수 있습니다- 예를 들면 서버에서 말이죠! 동일한 입력에 대해 동일한 결과를 반환하기 때문에 하나의 컴포넌트는 많은 사용자 요청을 처리할 수 있습니다.
- 입력이 변경되지 않은 컴포넌트 렌더링을 건너뛰어 성능을 향상시킬 수 있습니다. 순수 함수는 항상 동일한 결과를 반환하므로 캐시하기에 안전합니다.
- 깊은 컴포넌트 트리를 렌더링하는 도중에 일부 데이터가 변경되는 경우 React는 오래된 렌더링을 완료하는 데 시간을 낭비하지 않고 렌더링을 다시 시작할 수 있습니다. 순수함은 언제든지 연산을 중단하는 것을 안전하게 합니다.

우리가 구축하고 있는 모든 새로운 리액트 기능은 순수성을 활용합니다. 데이터 가져오기에서 애니메이션, 성능에 이르기까지 컴포넌트를 순수하게 유지하면 리액트 패러다임의 힘이 발휘됩니다.

## 1. 고장난 시계를 고쳐보세요

```jsx
export default function Clock({ time }) {
	let hours = time.getHours();
	let style;
	if (hours >= 0 && hours <= 6) {
		style = 'night';
	} else {
		style = 'day';
	}
	return <h1 className={style}>{time.toLocaleTimeString()}</h1>;
}
```

## 2. 망가진 프로필을 고쳐보세요

```jsx
import Panel from './Panel.js';
import { getImageUrl } from './utils.js';

export default function Profile({ person }) {
	return (
		<Panel>
			<Header name={person.name} />
			<Avatar person={person} />
		</Panel>
	);
}

function Header({ name }) {
	return <h1>{name}</h1>;
}

function Avatar({ person }) {
	return <img className="avatar" src={getImageUrl(person)} alt={person.name} width={50} height={50} />;
}
```

## 3. 깨진 StoryTray를 수리해보세요

```jsx
export default function StoryTray({ stories }) {
	return (
		<ul>
			{stories.map((story) => (
				<li key={story.id}>{story.label}</li>
			))}
			<li>Create Story</li>
		</ul>
	);
}
```
